{"version":3,"sources":["autoload.js"],"names":["Autoload","count","instance","undefined","args","autoload","channels","forEach","channel","callback","_channels","Array","isArray","times","length","ch","history","then","response","messages","m","message","entry","outputOn","push","sort","history_sort_attribute","catch"],"mappings":";;;;;;;;;AAAA;;;;;;;;IAEaA,Q,WAAAA,Q;AACX,sBAAc;AAAA;;AACZ,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,QAAL,GAAgBC,SAAhB;AACD;;;;+BAOUD,Q,EAAU;AACnB,WAAKA,QAAL,GAAgBA,QAAhB;AACD;;;+BAOUE,I,EAAM;AAAA;;AACf,UAAIA,KAAKC,QAAL,IAAiB,OAAOD,KAAKC,QAAZ,KAAyB,QAA9C,EAAwD;AACtD,aAAKJ,KAAL,CAAWG,KAAKE,QAAhB,IAA4BF,KAAKC,QAAjC;;AAEAD,aAAKE,QAAL,CAAcC,OAAd,CAAsB,UAACC,OAAD,EAAa;AACjC,gBAAKP,KAAL,CAAWO,OAAX,IAAsBJ,KAAKC,QAA3B;AACD,SAFD;AAGD;AACF;;;+BAQUG,O,EAASC,Q,EAAU;AAAA;;AAC5B,UAAI,KAAKR,KAAL,CAAWO,OAAX,CAAJ,EAAyB;AACvB,YAAIN,WAAW,KAAKA,QAApB;AACA,YAAIQ,YAAYC,MAAMC,OAAN,CAAcJ,OAAd,IAAyBA,OAAzB,GAAmC,CAACA,OAAD,CAAnD;AACA,YAAIK,QAAQH,UAAUI,MAAtB;;AAEAJ,kBAAUH,OAAV,CAAkB,UAACQ,EAAD,EAAQ;AACxBb,mBAASc,OAAT,CAAiB,EAAER,SAASO,EAAX,EAAed,OAAO,OAAKA,KAAL,CAAWO,OAAX,CAAtB,EAAjB,EAA8DS,IAA9D,CAAmE,UAACC,QAAD,EAAc;;AAE/EA,qBAASC,QAAT,CAAkBZ,OAAlB,CAA0B,UAACa,CAAD,EAAO;AAC/BA,gBAAEC,OAAF,GAAYD,EAAEE,KAAd;AACAF,gBAAEZ,OAAF,GAAYO,EAAZ;;AAEAb,uBAASqB,QAAT,CAAkBC,IAAlB,CAAuBhB,OAAvB,EAAgCY,CAAhC;AACD,aALD;;AAOAP,qBAAS,CAAT;;AAEA,gBAAIJ,YAAYI,UAAU,CAA1B,EAA6B;AAC3BX,uBAASqB,QAAT,CAAkBE,IAAlB,CAAuBjB,OAAvB,EAAgC,iBAAOkB,sBAAvC;AACAjB;AACD;AACF,WAfD,EAeGkB,KAfH,CAeS,YAAM,CAAE,CAfjB;AAgBD,SAjBD;AAkBD;AACF;;;gCAOWvB,I,EAAM;AAAA;;AAChB,UAAIO,MAAMC,OAAN,CAAcR,KAAKE,QAAnB,CAAJ,EAAkC;AAChCF,aAAKE,QAAL,CAAcC,OAAd,CAAsB,UAACQ,EAAD,EAAQ;AAC5B,cAAI,OAAKd,KAAL,CAAWc,EAAX,CAAJ,EAAoB,OAAO,OAAKd,KAAL,CAAWc,EAAX,CAAP;AACrB,SAFD;AAGD,OAJD,MAIO,IAAI,KAAKd,KAAL,CAAWG,KAAKE,QAAhB,CAAJ,EAA+B;AACpC,eAAO,KAAKL,KAAL,CAAWG,KAAKE,QAAhB,CAAP;AACD;AACF","file":"autoload.js","sourcesContent":["import config from '../config.json';\n\nexport class Autoload {\n  constructor() {\n    this.count = {};\n    this.instance = undefined;\n  }\n\n  /**\n   * Initialize the autoload with a wrapper instance\n   *\n   * @param instance\n   */\n  initialize(instance) {\n    this.instance = instance;\n  }\n\n  /**\n   * Enable the autoload for a channel or a set of channels subscribed\n   *\n   * @param args\n   */\n  enableLoad(args) {\n    if (args.autoload && typeof args.autoload === 'number') {\n      this.count[args.channels] = args.autoload;\n\n      args.channels.forEach((channel) => {\n        this.count[channel] = args.autoload;\n      });\n    }\n  }\n\n  /**\n   * Get history of a channel or a set of channels.\n   *\n   * @param {string|[string]} channel\n   * @param callback\n   */\n  getHistory(channel, callback) {\n    if (this.count[channel]) {\n      let instance = this.instance;\n      let _channels = Array.isArray(channel) ? channel : [channel];\n      let times = _channels.length;\n\n      _channels.forEach((ch) => {\n        instance.history({ channel: ch, count: this.count[channel] }).then((response) => {\n\n          response.messages.forEach((m) => {\n            m.message = m.entry;\n            m.channel = ch;\n\n            instance.outputOn.push(channel, m);\n          });\n\n          times -= 1;\n\n          if (callback && times === 0) {\n            instance.outputOn.sort(channel, config.history_sort_attribute);\n            callback();\n          }\n        }).catch(() => {});\n      });\n    }\n  }\n\n  /**\n   * Disable the autoload for a channel or set of channels\n   *\n   * @param args\n   */\n  disableLoad(args) {\n    if (Array.isArray(args.channels)) {\n      args.channels.forEach((ch) => {\n        if (this.count[ch]) delete this.count[ch];\n      });\n    } else if (this.count[args.channels]) {\n      delete this.count[args.channels];\n    }\n  }\n}\n"]}